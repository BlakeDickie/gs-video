/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package net.landora.video.module;

import java.util.*;
import javax.swing.table.TableCellEditor;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumn;
import net.landora.video.ui.BooleanCellEditor;
import net.landora.video.ui.BooleanCellRenderer;
import net.landora.video.ui.ConfigurationPanel;
import net.landora.video.utils.UIUtils;
import org.jdesktop.swingx.JXTreeTable;
import org.jdesktop.swingx.treetable.AbstractTreeTableModel;

/**
 *
 * @author bdickie
 */
public class ModuleConfigPanel extends ConfigurationPanel {

    private ModulesModel model;
    
    /**
     * Creates new form ModuleConfigPanel
     */
    public ModuleConfigPanel() {
        initComponents();
        
        
    }
    
    private Map<ModuleType,List<ModuleInterface>> modulesMap;
    private List<ModuleType> modulesList;
    private Set<ModuleInterface> disabledModules;

    @Override
    public void load() {
        modulesMap = new HashMap<ModuleType, List<ModuleInterface>>();
        modulesList = new ArrayList<ModuleType>();
        disabledModules = new HashSet<ModuleInterface>();
        for(ModuleType type: ModulesManager.getInstance().getConfiguredTypes()) {
            modulesList.add(type);
            
            List<ModuleInterface> modules = new ArrayList<ModuleInterface>();
            for(ModuleInterface module: ModulesManager.getInstance().getModules(type.getServiceClass())) {
                modules.add(module);
                // To ensure the values are pre-cached.
                module.isModuleConfigured();
                if (ModulesManager.getInstance().isModuleDisabled(module))
                    disabledModules.add(module);
            }
            modulesMap.put(type, modules);
            
        }
        
        Collections.sort(modulesList, UIUtils.LEXICAL_SORTER);
        
        model = new ModulesModel();
        treeModules.setTreeTableModel(model);
        
        TableColumn column = treeModules.getColumn(COL_ENABLED);
        int width = booleanCellRenderer.getPreferredSize().width;
        column.setPreferredWidth(width);
        column.setMinWidth(width);
        column.setMaxWidth(width);
    }

    @Override
    public void store() {
        ModulesManager.getInstance().setDisabledMofules(disabledModules);
    }

    @Override
    public boolean valid() {
        return true;
    }

    
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        treeModules = new TreeTableExt();

        setPanelName("Modules");
        setLayout(new java.awt.BorderLayout());

        jScrollPane1.setViewportView(treeModules);

        add(jScrollPane1, java.awt.BorderLayout.CENTER);
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane jScrollPane1;
    private org.jdesktop.swingx.JXTreeTable treeModules;
    // End of variables declaration//GEN-END:variables


    private static final int COL_ENABLED = 0;
    private static final int COL_NAME = COL_ENABLED + 1;
    private static final int COL_STATUS = COL_NAME + 1;

    private static final int NUM_COLS = COL_STATUS + 1;
    
    
    private class ModulesModel extends AbstractTreeTableModel {

        
        private Object rootObject;

        public ModulesModel() {
            super(new Object());
            rootObject = getRoot();
        }

        @Override
        public int getHierarchicalColumn() {
            return COL_NAME;
        }
        
        
        
        @Override
        public int getColumnCount() {
            return NUM_COLS;
        }

        @Override
        public String getColumnName(int column) {
            switch(column) {
                case COL_NAME:
                    return "Module";
                case COL_ENABLED:
                    return "";
                case COL_STATUS:
                    return "State";
                default:
                    return super.getColumnName(column);
            }
        }
        
        

        @Override
        public Object getValueAt(Object node, int column) {
            if (!(node instanceof ModuleInterface)) {
                switch(column) {
                    case COL_NAME:
                        return node;
                    case COL_ENABLED:
                        return null;
                    case COL_STATUS:
                        return "";
                    default:
                        return null;
                }
            }
            
            ModuleInterface module = (ModuleInterface)node;
            switch(column) {
                case COL_NAME:
                    return module.getModuleName();
                case COL_ENABLED:
                    return !disabledModules.contains(module);
                case COL_STATUS:
                    if (!module.isModuleUsable())
                        return "Not Usable";
                    else if (!module.isModuleConfigured())
                        return "Not Configured";
                    else
                        return "Ready";
                default:
                    return null;
            }
        }

        @Override
        public Object getChild(Object parent, int index) {
            if (parent == rootObject) {
                return modulesList.get(index);
            } else if (parent instanceof ModuleType) {
                return modulesMap.get((ModuleType)parent).get(index);
            } else
                throw new IllegalStateException("getChild called on leaf.");
        }

        @Override
        public boolean isLeaf(Object node) {
            if (node == rootObject) {
                return false;
            } else if (node instanceof ModuleType) {
                return false;
            } else
                return true;
        }
        
        

        @Override
        public int getChildCount(Object parent) {
            if (parent == rootObject) {
                return modulesList.size();
            } else if (parent instanceof ModuleType) {
                return modulesMap.get((ModuleType)parent).size();
            } else
                return 0;
        }

        @Override
        public int getIndexOfChild(Object parent, Object child) {
            if (parent == rootObject) {
                return modulesList.indexOf(child);
            } else if (parent instanceof ModuleType) {
                return modulesMap.get((ModuleType)parent).indexOf(child);
            } else
                throw new IllegalStateException("getIndexOfChild called on leaf.");
        }

        @Override
        public boolean isCellEditable(Object node, int column) {
            if (node instanceof ModuleInterface && column == COL_ENABLED)
                return true;
            return false;
        }

        @Override
        public void setValueAt(Object value, Object node, int column) {
            if (column == COL_ENABLED && node instanceof ModuleInterface) {
                boolean enabled = (Boolean)value;
                ModuleInterface module = (ModuleInterface)node;
                if (enabled)
                    disabledModules.remove(module);
                else
                    disabledModules.add(module);
                changed();
            }
        }
        
    }
    
    private BooleanCellRenderer booleanCellRenderer = new BooleanCellRenderer();
    private BooleanCellEditor booleanCellEditor = new BooleanCellEditor();
    
    private class TreeTableExt extends JXTreeTable {
    
        public TreeTableExt() {
        }

        @Override
        public TableCellRenderer getCellRenderer(int row, int column) {
            if (isHierarchical(column))
                return super.getCellRenderer(row, column);
            
            Object value = getValueAt(row, column);
            if (value instanceof Boolean) {
                return booleanCellRenderer;
            } else
                return super.getCellRenderer(row, column);
        }
        
        @Override
        public TableCellEditor getCellEditor(int row, int column) {
            if (isHierarchical(column))
                return super.getCellEditor(row, column);
            
            Object value = getValueAt(row, column);
            if (value instanceof Boolean) {
                return booleanCellEditor;
            } else
                return super.getCellEditor(row, column);
        }

//        @Override
//        public TableCellEditor getCellEditor(int row, int column) {
//            if (isHierarchical(column))
//                return super.getCellEditor(row, column);
//            
//            Object value = getValueAt(row, column);
//            if (value instanceof Boolean) {
//                return null;
//            } else {
//                return super.getCellEditor(row, column);
//        }
        
        
        
    }
    
}
